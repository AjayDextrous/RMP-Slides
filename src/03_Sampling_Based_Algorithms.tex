\documentclass{beamer}

\mode<presentation>
{
  \usetheme{umbc1}
  \setbeamercovered{transparent}
}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[]{datatool, filecontents}
\DTLsetseparator{=}
\DTLloaddb[noheader, keys={key,value}]{values}{./values.dat}
\newcommand{\var}[1]{\DTLfetch{values}{key}{#1}{value}}

\usepackage{tabularray}

\title[RMP v\var{version}]
{Robot Motion Planning}

\subtitle
{Sampling Based Algorithms}

\author[Narayanan]
{A.~Narayanan\inst{1}}

\institute[Technical University of Munich]
{
  \inst{1}
  Department of Informatics\\
}

\subject{Slides}

\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\begin{document}
\begin{frame}
    \titlepage
  \end{frame}
  
  \begin{frame}{Outline}
    \tableofcontents
  \end{frame}

  \section{Overview of Sampling Based Approaches}

  \begin{frame}{Difficulty with Classical Approaches}
    \begin{itemize}
      \item Curse of dimensionality
      \item Running time increases exponentially with dimensions of configuration space
      \item Several variants of the path planning problem have proven to be PSPACE-hard
    \end{itemize}
  \end{frame}

  \begin{frame}{Drawbacks of Combinatorial Approaches}
    
  \end{frame}

  \section[PRMs]{Probablilistic Roadmaps}

  \begin{frame}
    \frametitle{Multiple Query Roadmaps}
    A multiple query approach tries to capture the connectivity of the
free space as good as possible, such that multiple, different queries
for paths can be answered very fast. In other words: create a
roadmap that is suitable for as many use cases as p
    
  \end{frame}

  \begin{frame}
    \frametitle{PRM - Probablistic Roadmaps}
    Basic steps to construct a PRM:
    \begin{enumerate}
      \item sample vertices and keep vertices that do not lie on an obstacle
      \item find neighbour vertices - k-nearest neighbour or neighbours within a specified radius
      \item connect neighbouring vertices with edges (lines) (and check for collisions on connecting line using e.g. discretized line search)
      \item add vertices and edges until roadmap is dense enough
    \end{enumerate}
  
  \end{frame}

  \begin{frame}
    \frametitle{PRM Visualized}
  
  \end{frame}

  \begin{frame}
    \frametitle{Drawbacks}
    PRMs don't perform well when there are narrow passages.
  
  \end{frame}

  \begin{frame}
    \frametitle{How to Improve?}
    \begin{itemize}
      \item Increase number of milestones
      \item Random walk
      \item Path Correction
      \item Sample at obstacle boundaries
    \end{itemize}
    
  
  \end{frame}

  \begin{frame}
    \frametitle{OBPRM - Obstacle Based PRM}
    Obstacle-based PRMs are constructed by sampling only close to
obstacles. During sampling, the first goal is to find a point that
lies inside an obstacle. Then, another point is sampled at an
arbitrary distance to the first point. Using step-wise approximation, a point sufficiently close to the obstacle border is searched.
  
  \end{frame}

  \begin{frame}
    \frametitle{Single Query Roadmaps}
    Single query planners try to solve a single query as fast as possible, without trying to cover the whole free space
    
  \end{frame}

  \begin{frame}
    \frametitle{Weighted Randomized Tree Expansion}
    \begin{enumerate}
      \item expand trees from start and goal
      \item pick a node with probability = $1/w(x)$, with $w(x)$ being the amount of neighbors within radius (measurement for exploration around x)
      \item sample $k$ points $(y_{1}, \dots, y_{k})$ around $x$
      \item add $y_{i}$ to the tree if
        \begin{itemize}
        \item $1/w(y_{i}) > 1/w(x)$
        \item $y_{i}$ is collision free
        \item $y_{i}$ can see $x$
        \end{itemize}
      \item if a pair of nodes from start tree and goal tree are close and can see each other, then connect them and terminate
    \end{enumerate}  
  
  \end{frame}

  \begin{frame}
    \frametitle{Rapidly Exploring Random Trees}
    \begin{enumerate}
      \item pick $q_{start}$ as the first node
      \item pick a random target location (every $n^{th}$ iteration, choose $q_{goal}$)
      \item find closest vertex in roadmap
      \item extend this vertex towards target location
      \item repeat steps until $q_{goal}$ is reached
    \end{enumerate}

    For faster execution, the tree can be grown from both $q_{start}$ and $q_{goal}$
  
  \end{frame}

  \begin{frame}
    \frametitle{How to sample}
  
  \end{frame}

  \begin{frame}
    \frametitle{Path Smoothening}
  \end{frame}

  \subsection{Expansiveness}

  \begin{frame}
    \frametitle{$\epsilon, \alpha, \beta$ - Expansiveness}
  
  \end{frame}


\end{document}